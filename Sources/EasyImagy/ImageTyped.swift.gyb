% channel_types = [
%   'UInt8',
%   'UInt16',
%   'UInt32',
%   'Int',
%   'Float',
%   'Double',
% ]
% types = [f'RGBA<{t}>' for t in channel_types] + channel_types
%
% for i, type in enumerate(types):
%   if i > 0:

%   end
extension Image where Pixel == ${type} { // Convolution
    public func convoluted(with kernel: Image<Int>, extrapolatedBy extrapolationMethod: ExtrapolationMethod<${type}> = .edging) -> Image<${type}> {
        return self.convoluted(with: kernel, extrapolatedBy: extrapolationMethod, toSummable: { $0.summableI }, product: Pixel.productI, zero: Pixel.summableIZero, sum: +, toOriginal: Pixel.init(summableI:))
    }

    public func convoluted(with kernel: Image<Float>, extrapolatedBy extrapolationMethod: ExtrapolationMethod<${type}> = .edging) -> Image<${type}> {
        return self.convoluted(with: kernel, extrapolatedBy: extrapolationMethod, toSummable: { $0.summableF }, product: Pixel.productF, zero: Pixel.summableFZero, sum: +, toOriginal: Pixel.init(summableF:))
    }

    public func convoluted(with kernel: Image<Double>, extrapolatedBy extrapolationMethod: ExtrapolationMethod<${type}> = .edging) -> Image<${type}> {
        return self.convoluted(with: kernel, extrapolatedBy: extrapolationMethod, toSummable: { $0.summableD }, product: Pixel.productD, zero: Pixel.summableDZero, sum: +, toOriginal: Pixel.init(summableD:))
    }
}
% end
%
% for i, type in enumerate(types):

extension Image where Pixel == ${type} { // Interpolation, Transformation
    // Not implemented by default parameter values to improve performance especially when this `subscript` is called repeatedly
    public subscript(x: Float, y: Float) -> ${type} {
        return interpolatedPixelByBilinear(x: x, y: y, toSummable: { $0.summableF }, product: Pixel.productF, sum: +, toOriginal: Pixel.init(summableF:)) { self[$0, $1] }
    }

    public subscript(x: Float, y: Float, interpolatedBy interpolationMethod: InterpolationMethod) -> ${type} {
        switch interpolationMethod {
            case .nearestNeighbor:
                return interpolatedPixelByNearestNeighbor(x: x, y: y) { self[$0, $1] }
            case .bilinear:
                return interpolatedPixelByBilinear(x: x, y: y, toSummable: { $0.summableF }, product: Pixel.productF, sum: +, toOriginal: Pixel.init(summableF:)) { self[$0, $1] }
        }
    }
    
    public subscript(x: Float, y: Float, interpolatedBy interpolationMethod: InterpolationMethod, extrapolatedBy extrapolationMethod: ExtrapolationMethod<Pixel>) -> ${type} {
        switch interpolationMethod {
            case .nearestNeighbor:
                return interpolatedPixelByNearestNeighbor(x: x, y: y) { self[$0, $1, extrapolatedBy: extrapolationMethod] }
            case .bilinear:
                return interpolatedPixelByBilinear(x: x, y: y, toSummable: { $0.summableF }, product: Pixel.productF, sum: +, toOriginal: Pixel.init(summableF:)) { self[$0, $1, extrapolatedBy: extrapolationMethod] }
        }
    }

    public func transformed(width: Int, height: Int, transform: (Float, Float) -> (Float, Float)) -> Image<${type}> {
        return self._transformed(width: width, height: height, toSummable: { $0.summableF }, product: Pixel.productF, sum: +, toOriginal: Pixel.init(summableF:), transform: transform)
    }
}
% end
%
% types = ['Int', 'Int8', 'Int16', 'Int32', 'Int64', 'UInt', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float', 'Double', 'Bool']
% arithmetic_operators = ['+', '-', '*', '/']
% float_operators = arithmetic_operators
% int_operators = arithmetic_operators + ['%', '&', '|', '^']
% bool_operators = ['&&', '||']
% float_operators = float_operators + [o + '=' for o in float_operators]
% int_operators = int_operators + ['&' + o for o in arithmetic_operators if o != '/'] + [o + '=' for o in  int_operators]
% type_to_operators = { type: int_operators if 'Int' in type else (bool_operators if type == 'Bool' else float_operators) for type in types }
% for channel, type in [(t, f'RGBA<{t}>') for t in types] + [(t, t) for t in types]:

extension Image where Pixel == ${type} {
%   for i, operator in enumerate(type_to_operators[channel]):
%     if i > 0:

%     end
%     if operator.endswith('='):
    public static func ${operator}(lhs: inout Image<${type}>, rhs: Image<${type}>) {
        for i in lhs.pixels.indices {
            lhs.pixels[i] ${operator} rhs.pixels[i]
        }
%     else:
    public static func ${operator}(lhs: Image<${type}>, rhs: Image<${type}>) -> Image<${type}> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`${operator} cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ${operator} $1 }
        return Image<${type}>(width: lhs.width, height: lhs.height, pixels: pixels)
%     end
    }
%   end
}
% end
