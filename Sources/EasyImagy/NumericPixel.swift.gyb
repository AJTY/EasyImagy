% types = ['UInt8', 'UInt16', 'UInt32', 'Int', 'Float', 'Double']
% summable_types = ['Int', 'Int64', 'Float', 'Double']
% type_to_summables = {
%   'UInt8' : ['Int', 'Float', 'Double'],
%   'UInt16': ['Int', 'Float', 'Double'],
%   'UInt32': ['Int64', 'Float', 'Double'],
%   'Int'   : ['Int', 'Float', 'Double'],
%   'Float' : ['Float', 'Float', 'Double'],
%   'Double': ['Double', 'Double', 'Double'],
% }
% summable_sybmols = ['Int', 'Float', 'Double']
% summable_weights = ['Int', 'Float', 'Double']
%
import Foundation

public protocol _Summable {
    static func _ez_sum(_ lhs: Self, _ rhs: Self) -> Self
}

% for type in summable_types:
extension ${type} : _Summable { public static func _ez_sum(_ lhs: ${type}, _ rhs: ${type}) -> ${type} { return lhs + rhs } }
% end
extension RGBA : _Summable where Channel : _Summable {
    @inlinable
    public static func _ez_sum(_ lhs: RGBA<Channel>, _ rhs: RGBA<Channel>) -> RGBA<Channel> {
        return RGBA<Channel>(
            red  : Channel._ez_sum(lhs.red  , rhs.red),
            green: Channel._ez_sum(lhs.green, rhs.green),
            blue : Channel._ez_sum(lhs.blue , rhs.blue),
            alpha: Channel._ez_sum(lhs.alpha, rhs.alpha)
        )
    }
}

public protocol _NumericPixel {
    associatedtype IntType    : _Summable
    associatedtype FloatType  : _Summable
    associatedtype DoubleType : _Summable

    init(_ez_summableInt: IntType)
    init(_ez_summableFloat: FloatType)
    init(_ez_summableDouble: DoubleType)
    var _ez_summableInt: IntType { get }
    var _ez_summableFloat: FloatType { get }
    var _ez_summableDouble: DoubleType { get }
    static var _ez_zero: Self { get }
    static var _ez_summableIntZero: IntType { get }
    static var _ez_summableFloatZero: FloatType { get }
    static var _ez_summableDoubleZero: DoubleType { get }
    static func _ez_productInt(_ lhs: IntType, _ rhs: Int) -> IntType
    static func _ez_productFloat(_ lhs: FloatType, _ rhs: Float) -> FloatType
    static func _ez_productDouble(_ lhs: DoubleType, _ rhs: Double) -> DoubleType
    static func _ez_quotientInt(_ lhs: IntType, _ rhs: Int) -> IntType
    static func _ez_quotientFloat(_ lhs: FloatType, _ rhs: Float) -> FloatType
    static func _ez_quotientDouble(_ lhs: DoubleType, _ rhs: Double) -> DoubleType
}

extension RGBA : _NumericPixel where Channel : _NumericPixel {
    public typealias IntType = RGBA<Channel.IntType>
    public typealias FloatType = RGBA<Channel.FloatType>
    public typealias DoubleType = RGBA<Channel.DoubleType>
    
    @inlinable
    public init(_ez_summableInt: RGBA<Channel.IntType>) {
        self = RGBA<Channel>(red: Channel.init(_ez_summableInt: _ez_summableInt.red), green: Channel.init(_ez_summableInt: _ez_summableInt.green), blue: Channel.init(_ez_summableInt: _ez_summableInt.blue), alpha: Channel.init(_ez_summableInt: _ez_summableInt.alpha))
    }
    
    @inlinable
    public init(_ez_summableFloat: RGBA<Channel.FloatType>) {
        self = RGBA<Channel>(red: Channel.init(_ez_summableFloat: _ez_summableFloat.red), green: Channel.init(_ez_summableFloat: _ez_summableFloat.green), blue: Channel.init(_ez_summableFloat: _ez_summableFloat.blue), alpha: Channel.init(_ez_summableFloat: _ez_summableFloat.alpha))
    }
    
    @inlinable
    public init(_ez_summableDouble: RGBA<Channel.DoubleType>) {
        self = RGBA<Channel>(red: Channel.init(_ez_summableDouble: _ez_summableDouble.red), green: Channel.init(_ez_summableDouble: _ez_summableDouble.green), blue: Channel.init(_ez_summableDouble: _ez_summableDouble.blue), alpha: Channel.init(_ez_summableDouble: _ez_summableDouble.alpha))
    }
    
    public var _ez_summableInt: RGBA<Channel.IntType> {
        return RGBA<Channel.IntType>(red: red._ez_summableInt, green: green._ez_summableInt, blue: blue._ez_summableInt, alpha: alpha._ez_summableInt)
    }
    
    public var _ez_summableFloat: RGBA<Channel.FloatType> {
        return RGBA<Channel.FloatType>(red: red._ez_summableFloat, green: green._ez_summableFloat, blue: blue._ez_summableFloat, alpha: alpha._ez_summableFloat)
    }
    
    public var _ez_summableDouble: RGBA<Channel.DoubleType> {
        return RGBA<Channel.DoubleType>(red: red._ez_summableDouble, green: green._ez_summableDouble, blue: blue._ez_summableDouble, alpha: alpha._ez_summableDouble)
    }
    
    public static var _ez_zero: RGBA<Channel> {
        return RGBA<Channel>(red: Channel._ez_zero, green: Channel._ez_zero, blue: Channel._ez_zero, alpha: Channel._ez_zero)
    }
    
    public static var _ez_summableIntZero: RGBA<Channel.IntType> {
        let zero = Channel._ez_summableIntZero
        return RGBA<Channel.IntType>(red: zero, green: zero, blue: zero, alpha: zero)
    }
    
    public static var _ez_summableFloatZero: RGBA<Channel.FloatType> {
        let zero = Channel._ez_summableFloatZero
        return RGBA<Channel.FloatType>(red: zero, green: zero, blue: zero, alpha: zero)
    }
    
    public static var _ez_summableDoubleZero: RGBA<Channel.DoubleType> {
        let zero = Channel._ez_summableDoubleZero
        return RGBA<Channel.DoubleType>(red: zero, green: zero, blue: zero, alpha: zero)
    }
    
    @inlinable
    public static func _ez_productInt(_ lhs: RGBA<Channel.IntType>, _ rhs: Int) -> RGBA<Channel.IntType> {
        return RGBA<Channel.IntType>(red: Channel._ez_productInt(lhs.red, rhs), green: Channel._ez_productInt(lhs.green, rhs), blue: Channel._ez_productInt(lhs.blue, rhs), alpha: Channel._ez_productInt(lhs.alpha, rhs))
    }
    
    @inlinable
    public static func _ez_productFloat(_ lhs: RGBA<Channel.FloatType>, _ rhs: Float) -> RGBA<Channel.FloatType> {
        return RGBA<Channel.FloatType>(red: Channel._ez_productFloat(lhs.red, rhs), green: Channel._ez_productFloat(lhs.green, rhs), blue: Channel._ez_productFloat(lhs.blue, rhs), alpha: Channel._ez_productFloat(lhs.alpha, rhs))
    }
    
    @inlinable
    public static func _ez_productDouble(_ lhs: RGBA<Channel.DoubleType>, _ rhs: Double) -> RGBA<Channel.DoubleType> {
        return RGBA<Channel.DoubleType>(red: Channel._ez_productDouble(lhs.red, rhs), green: Channel._ez_productDouble(lhs.green, rhs), blue: Channel._ez_productDouble(lhs.blue, rhs), alpha: Channel._ez_productDouble(lhs.alpha, rhs))
    }
    
    @inlinable
    public static func _ez_quotientInt(_ lhs: RGBA<Channel.IntType>, _ rhs: Int) -> RGBA<Channel.IntType> {
        return RGBA<Channel.IntType>(red: Channel._ez_quotientInt(lhs.red, rhs), green: Channel._ez_quotientInt(lhs.green, rhs), blue: Channel._ez_quotientInt(lhs.blue, rhs), alpha: Channel._ez_quotientInt(lhs.alpha, rhs))
    }
    
    @inlinable
    public static func _ez_quotientFloat(_ lhs: RGBA<Channel.FloatType>, _ rhs: Float) -> RGBA<Channel.FloatType> {
        return RGBA<Channel.FloatType>(red: Channel._ez_quotientFloat(lhs.red, rhs), green: Channel._ez_quotientFloat(lhs.green, rhs), blue: Channel._ez_quotientFloat(lhs.blue, rhs), alpha: Channel._ez_quotientFloat(lhs.alpha, rhs))
    }
    
    @inlinable
    public static func _ez_quotientDouble(_ lhs: RGBA<Channel.DoubleType>, _ rhs: Double) -> RGBA<Channel.DoubleType> {
        return RGBA<Channel.DoubleType>(red: Channel._ez_quotientDouble(lhs.red, rhs), green: Channel._ez_quotientDouble(lhs.green, rhs), blue: Channel._ez_quotientDouble(lhs.blue, rhs), alpha: Channel._ez_quotientDouble(lhs.alpha, rhs))
    }
}
% for type in types:

extension ${type} : _NumericPixel {
%   summables = type_to_summables[type]
%
%   for i, (summable_symbol, summable) in enumerate(zip(summable_sybmols, summables)):
%     if i > 0:

%     end
    public init(_ez_summable${summable_symbol}: ${summable}) {
%     if summable == type:
        self = _ez_summable${summable_symbol}
%     else:
        self = ${type}(_ez_summable${summable_symbol})
%     end
    }
%   end
%
%   for summable_symbol, summable in zip(summable_sybmols, summables):
    
    public var _ez_summable${summable_symbol}: ${summable} {
%     if summable == type:
        return self
%     else:
        return ${summable}(self)
%     end
    }
%   end

    public static var _ez_zero: ${type} {
        return 0
    }

%   for summable_symbol, summable in zip(summable_sybmols, summables):
    
    public static var _ez_summable${summable_symbol}Zero: ${summable} {
        return 0
        
    }
%   end
%
%   for summable_symbol, summable_weight, summable in zip(summable_sybmols, summable_weights, summables):
    
    public static func _ez_product${summable_symbol}(_ lhs: ${summable}, _ rhs: ${summable_weight}) -> ${summable} {
%     if summable_weight == summable:
        return lhs * rhs
%     else:
        return lhs * ${summable}(rhs)
%     end
    }
%   end
%
%   for summable_symbol, summable_weight, summable in zip(summable_sybmols, summable_weights, summables):
    
    public static func _ez_quotient${summable_symbol}(_ lhs: ${summable}, _ rhs: ${summable_weight}) -> ${summable} {
%     if summable_weight == summable:
        return lhs / rhs
%     else:
        return lhs / ${summable}(rhs)
%     end
    }
%   end
}
% end
