% channel_types = [
%   'UInt8',
%   'UInt16',
%   'UInt32',
%   'Int',
%   'Float',
%   'Double',
% ]
% types = [f'RGBA<{t}>' for t in channel_types] + channel_types
%
import Foundation

% for i, type in enumerate(types):
extension ImageProtocol where Element == ${type} { // Resizing
%   if i > 0:

%   end
%   for j, explicit_interpolation in enumerate([False, True]):
%     if j > 0:

%     end
    public func resizedTo(width: Int, height: Int${', interpolatedBy interpolationMethod: InterpolationMethod' if explicit_interpolation else ''}) -> Image<Pixel> {
        let ox = xRange.lowerBound
        let oy = yRange.lowerBound
%     if explicit_interpolation:
        let isAntialiased: Bool
        if case .nearestNeighbor = interpolationMethod {
            isAntialiased = false
        } else {
            isAntialiased = true
        }
%     end
%     for has_offset in [False, True]:
%       if not has_offset:
        if ox == 0 && oy == 0 {
%       else:
        } else {
            let dox = Double(ox)
            let doy = Double(oy)
%       end
            return resizedTo(
                width: width,
                height: height,
%     if explicit_interpolation:
                isAntialiased: isAntialiased,
%     else:
                isAntialiased: true,
%     end
                toSummable: { $0.summableI },
                zero: Pixel.summableIZero,
                sum: +,
                quotient: { a, b in Pixel.init(summableI: Pixel.quotientI(a, b)) },
                pixelAt: { x, y in self[${'dox + x, doy + y' if has_offset else 'x, y'}${', interpolatedBy: interpolationMethod' if explicit_interpolation else ''}] },
                extrapolatedPixelAt: { x, y in self[${'dox + x, doy + y' if has_offset else 'x, y'}${', interpolatedBy: interpolationMethod' if explicit_interpolation else ''}, extrapolatedBy: .edge] }
            )
%     end
        }
    }
%   end
}
% end
%
% for i, type in enumerate(types):

extension ImageProtocol where Element == ${type} { // Rotation
    public func rotated(byDegrees angle: Int) -> Image<Pixel> {
        if angle % 90 == 0 {
            return rotated(byRightAngleInDegrees: angle)
        } else {
            return rotated(byDegrees: Double(angle))
        }
    }

    public func rotated(by angle: Double) -> Image<Pixel> {
        return rotatedImageWith(angle: angle) { self[$0, $1, interpolatedBy: .bilinear, extrapolatedBy: .filling(.selfZero)] }
    }
    
    public func rotated(byDegrees angle: Double) -> Image<Pixel> {
        return rotated(by: angle / 180.0 * .pi)
    }

    public func rotated(by angle: Double, extrapolatedBy extrapolationMethod: ExtrapolationMethod<Pixel>) -> Image<Pixel> {
        return rotatedImageWith(angle: angle) { self[$0, $1, interpolatedBy: .bilinear, extrapolatedBy: extrapolationMethod] }
    }
    
    public func rotated(byDegrees angle: Double, extrapolatedBy extrapolationMethod: ExtrapolationMethod<Pixel>) -> Image<Pixel> {
        return rotated(by: angle / 180.0 * .pi, extrapolatedBy: extrapolationMethod)
    }

    public func rotated(by angle: Double, interpolatedBy interpolationMethod: InterpolationMethod, extrapolatedBy extrapolationMethod: ExtrapolationMethod<Pixel>) -> Image<Pixel> {
        return rotatedImageWith(angle: angle) { self[$0, $1, interpolatedBy: interpolationMethod, extrapolatedBy: extrapolationMethod] }
    }
    
    public func rotated(byDegrees angle: Double, interpolatedBy interpolationMethod: InterpolationMethod, extrapolatedBy extrapolationMethod: ExtrapolationMethod<Pixel>) -> Image<Pixel> {
        return rotated(by: angle / 180.0 * .pi, interpolatedBy: interpolationMethod, extrapolatedBy: extrapolationMethod)
    }
}
% end

extension ImageProtocol where Element == RGBA<Bool> { // Rotation
    public func rotated(byDegrees angle: Int) -> Image<Pixel> {
        if angle % 90 == 0 {
            return rotated(byRightAngleInDegrees: angle)
        } else {
            return rotated(byDegrees: Double(angle))
        }
    }

    public func rotated(by angle: Double) -> Image<Pixel> {
        return rotatedImageWith(angle: angle) { self[Int(round($0)), Int(round($1)), extrapolatedBy: .filling(RGBA<Bool>(red: false, green: false, blue: false, alpha: false))] }
    }
    
    public func rotated(byDegrees angle: Double) -> Image<Pixel> {
        return rotated(by: angle / 180.0 * .pi)
    }
}

extension ImageProtocol where Element == Bool { // Rotation
    public func rotated(byDegrees angle: Int) -> Image<Pixel> {
        if angle % 90 == 0 {
            return rotated(byRightAngleInDegrees: angle)
        } else {
            return rotated(byDegrees: Double(angle))
        }
    }

    public func rotated(by angle: Double) -> Image<Pixel> {
        return rotatedImageWith(angle: angle) { self[Int(round($0)), Int(round($1)), extrapolatedBy: .filling(false)] }
    }
    
    public func rotated(byDegrees angle: Double) -> Image<Pixel> {
        return rotated(by: angle / 180.0 * .pi)
    }
}
